<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mayatete (Chromakey)</title>
    
    <!-- Tailwind CSSã®èª­ã¿è¾¼ã¿ --><script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.jsã®èª­ã¿è¾¼ã¿ --><script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Handsã®èª­ã¿è¾¼ã¿ --><script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>
    <!-- MediaPipe CameraUtils --><script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>
    
    <style>
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #f7fafc; 
            margin: 0; 
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #threeDContainer {
            width: 100vw;
            height: 100vh;
        }
        #threeDCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

    <!-- 3Dãƒ¢ãƒ‡ãƒ«ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã®ã‚³ãƒ³ãƒ†ãƒŠã®ã¿ --><div id="threeDContainer">
        <canvas id="threeDCanvas"></canvas>
    </div>

    <!-- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ --><div id="messageBox" class="rounded-lg shadow-lg" style="position:fixed; top:10px; left:50%; transform:translateX(-50%); z-index:10; padding: 10px; background: rgba(255, 255, 255, 0.9); border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">
        ã‚«ãƒ¡ãƒ©ã®èµ·å‹•ã‚’å¾…ã£ã¦ã„ã¾ã™...
    </div>

    <script>
        // MediaPipe Handsã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯æ¥ç¶šå®šç¾© (ãƒ¡ãƒƒã‚·ãƒ¥ç”¨)
        const BONE_CONNECTIONS = [
            // Fingers
            [0, 1], [1, 2], [2, 3], [3, 4],
            [5, 6], [6, 7], [7, 8],
            [9, 10], [10, 11], [11, 12],
            [13, 14], [14, 15], [15, 16],
            [17, 18], [18, 19], [19, 20],
            
            // Metacarpals
            [0, 5], [0, 9], [0, 13], [0, 17],
            [5, 9], [9, 13], [13, 17]
        ];
        
        // Thumb landmarks
        const THUMB_LANDMARKS = [0, 1, 2, 3, 4];
        
        // æŒ‡å…ˆã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ID
        const TIP_LANDMARKS = [4, 8, 12, 16, 20];
        // æŒ‡ã®ä»˜ã‘æ ¹ï¼ˆæ‰‹ã®ã²ã‚‰ã«æ¥ã™ã‚‹éƒ¨åˆ†ï¼‰ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ID
        const BASE_JOINT_LANDMARKS = [1, 5, 9, 13, 17]; 

        // å…±é€šã®å¤ªã•èª¿æ•´å®šæ•°
        const JOINT_RADIUS_FACTOR = 0.8; // ä»–ã®é–¢ç¯€ã®åŸºæœ¬å€ç‡
        const TIP_RADIUS_FACTOR = 0.8;   // <<< æŒ‡å…ˆã®å¤ªã•ã‚’ 0.8 ã«ãƒ–ãƒ¼ã‚¹ãƒˆ >>>
        
        // --- UI elements ---
        const messageBox = document.getElementById('messageBox');
        
        // --- Three.js Setup ---
        let scene, camera, renderer;
        const handMeshes = []; 

        // è‚Œã®è‰² (æŒ‡å®šã•ã‚ŒãŸè‰²)
        const flatColor = 0xFFEEE2; 
        // ç·šã®è‰²ã‚’å¤‰æ›´ (æŒ‡å®šã•ã‚ŒãŸè‰²)
        const outlineColor = 0x5A4F47; 

        // 1. ãƒ¡ã‚¤ãƒ³ã®ã‚½ãƒªãƒƒãƒ‰ãƒœãƒ‡ã‚£ç”¨ãƒãƒ†ãƒªã‚¢ãƒ« (æŒ‡ã€é–¢ç¯€ã€æ‰‹é¦–ç”¨)
        const flatMaterial = new THREE.MeshBasicMaterial({ 
            color: flatColor,
            side: THREE.DoubleSide,
            polygonOffset: true,
            polygonOffsetFactor: -10.0, // é€šå¸¸ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ (æ‰‹å‰)
            polygonOffsetUnits: -10.0
        }); 

        // 1b. æ‰‹ã®ã²ã‚‰å°‚ç”¨ãƒãƒ†ãƒªã‚¢ãƒ« (Z-fightingå¯¾ç­–ã‚’è¶…å¼·åŒ–)
        const flatPalmMaterial = new THREE.MeshBasicMaterial({
            color: flatColor,
            side: THREE.DoubleSide,
            polygonOffset: true,
            polygonOffsetFactor: -50.0, // å€¤ã‚’å¤§å¹…ã«å¼·åŒ– (ã‚ˆã‚Šæ‰‹å‰ã«)
            polygonOffsetUnits: -50.0  // å€¤ã‚’å¤§å¹…ã«å¼·åŒ–
        });

        // 2. ã‚·ãƒ«ã‚¨ãƒƒãƒˆã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ç”¨ãƒãƒ†ãƒªã‚¢ãƒ« (æŒ‡å®šã•ã‚ŒãŸè‰²ã€è£é¢ã®ã¿æç”»)
        const blackOutlineMaterial = new THREE.MeshBasicMaterial({ 
            color: outlineColor, // ã“ã“ã§å¤‰æ›´
            side: THREE.BackSide, // è£é¢æç”»ã®ã¿
            polygonOffset: true,
            polygonOffsetFactor: 5.0, // 5.0 ã«è¨­å®š (æœ¬ä½“ã«è¿‘ã¥ã‘ã‚‹)
            polygonOffsetUnits: 5.0
        });
        
        // Mesh resolution (segments)
        const MESH_SEGMENTS = 32; 

        // Scaling factor for MediaPipe coordinates in 3D space
        const worldScale = 10; 
        
        // Smoothing settings
        const smoothingFactor = 0.4; 
        
        // Thickness ratios
        const FINGER_THICKNESS_RATIO = 0.40; 
        
        // æ‰‹é¦–ã®å¤ªã•ã®å€ç‡
        const WRIST_THICKNESS_RATIO = 1.2;  // è…•ã®é ã„å´ã®å¤ªã•ã®ãƒ™ãƒ¼ã‚¹
        const L0_EMPHASIS_FACTOR = 2.5;     // æ‰‹é¦–ã®çƒä½“ã®å¤ªã•
        
        const EXTRA_DOT_THICKNESS_RATIO = 0.30; // Thickness of the extra wrist dot
        
        // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã®ç´°ã•èª¿æ•´
        const OUTLINE_SCALE_FACTOR = 1.07; // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã®å¤ªã• (åŸºæœ¬å€ç‡: éª¨ã€æŒ‡å…ˆã€æŒ‡ã®ä»˜ã‘æ ¹ã«é©ç”¨)
        const L0_OUTLINE_THICKNESS_SCALE = 1.03; // L0 (æ‰‹é¦–ã®çƒä½“) å°‚ç”¨ã®ç´°ã„ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³å€ç‡
        const PALM_OUTLINE_SCALE = 1.03; // æ‰‹ã®ã²ã‚‰ãƒ¡ãƒƒã‚·ãƒ¥å°‚ç”¨ã®ç´°ã„ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³å€ç‡

        // æŒ‡ã®é–¢ç¯€ã ã‘ã‚’å¤ªãã™ã‚‹ãƒ–ãƒ¼ã‚¹ãƒˆä¿‚æ•° (L0, æŒ‡å…ˆ, æŒ‡ã®ä»˜ã‘æ ¹ä»¥å¤–ã«é©ç”¨)
        const JOINT_OUTLINE_BOOST = 1.05; 

        const wristOffsetX = 0.1; // X-axis offset for the wrist cylinder
        
        // [è…•ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®é•·ã•è¨­å®š]
        const wristLengthFactor = 0.9; // ãƒ”ãƒ³ã‚¯ã®ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®é•·ã• (é•·ã„)
        const outlineWristLengthFactor = 0.60; // é»’ã„ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ç”¨ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®é•·ã• 

        // [é»’ã„ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨­å®š]
        const outlineWristStartOffsetFactor = 0.08; 
        
        // è…•ã®é ã„å´ã®ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã‚’ç´°ãã™ã‚‹ãƒ†ãƒ¼ãƒ‘ãƒ¼ä¿‚æ•°
        const OUTLINE_TAPER_FACTOR = 0.85; 

        /**
         * Creates all meshes and objects for a single hand.
         * @returns {object} Hand mesh, line, and state objects
         */
        function createHandMeshes() {
            const hand = {
                // ãƒ¡ã‚¤ãƒ³ãƒœãƒ‡ã‚£
                spheres: [],         
                cylinders: [],       
                wristCylinder: null, 
                palmMesh: null,      
                extraWristDot: null, // è‚Œè‰²ã®ç‚¹
                
                // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ç”¨ãƒ¡ãƒƒã‚·ãƒ¥
                outlineSpheres: [],
                outlineCylinders: [],
                outlineWristCylinder: null,
                outlinePalmMesh: null,

                smoothedLandmarks: [],
                isVisible: false
            };

            // === Mesh elements creation ===
            const sphereGeometry = new THREE.SphereGeometry(1.0, MESH_SEGMENTS, MESH_SEGMENTS); 
            // åˆæœŸã‚¸ã‚ªãƒ¡ãƒˆãƒªï¼ˆãƒ€ãƒŸãƒ¼ï¼‰
            const cylinderGeometry = new THREE.CylinderGeometry(1.0, 1.0, 1, MESH_SEGMENTS); 
            
            // 1. Create all joint spheres (21 points)
            for (let i = 0; i < 21; i++) {
                // ãƒ¡ã‚¤ãƒ³ (flatMaterial ã‚’ä½¿ç”¨)
                const sphere = new THREE.Mesh(sphereGeometry, flatMaterial); 
                sphere.visible = false; 
                sphere.renderOrder = 1; // ãƒ¡ã‚¤ãƒ³ã‚’å¾Œã«æç”»
                scene.add(sphere);
                hand.spheres.push(sphere);
                
                // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ (é»’)
                const outlineSphere = new THREE.Mesh(sphereGeometry, blackOutlineMaterial); 
                outlineSphere.visible = false; 
                outlineSphere.renderOrder = 0; // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã‚’å…ˆã«æç”»
                scene.add(outlineSphere);
                hand.outlineSpheres.push(outlineSphere);
            }

            // 2. Create the extra wrist dot (ãƒ¡ã‚¤ãƒ³ã®ã¿, flatMaterial ã‚’ä½¿ç”¨)
            hand.extraWristDot = new THREE.Mesh(sphereGeometry, flatMaterial); 
            hand.extraWristDot.visible = false;
            hand.extraWristDot.renderOrder = 1; // ãƒ¡ã‚¤ãƒ³ã‚’å¾Œã«æç”»
            scene.add(hand.extraWristDot);

            // 3. Create all bone cylinders (BONE_CONNECTIONS count)
            BONE_CONNECTIONS.forEach(() => {
                // ãƒ¡ã‚¤ãƒ³ (flatMaterial ã‚’ä½¿ç”¨)
                const cylinder = new THREE.Mesh(cylinderGeometry, flatMaterial); 
                cylinder.visible = false; 
                cylinder.renderOrder = 1; // ãƒ¡ã‚¤ãƒ³ã‚’å¾Œã«æç”»
                scene.add(cylinder);
                hand.cylinders.push(cylinder);

                // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ (é»’)
                const outlineCylinder = new THREE.Mesh(cylinderGeometry, blackOutlineMaterial); 
                outlineCylinder.visible = false; 
                outlineCylinder.renderOrder = 0; // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã‚’å…ˆã«æç”»
                scene.add(outlineCylinder);
                hand.outlineCylinders.push(outlineCylinder);
            });

            // 4. Initialize wrist cylinder
            // è…•ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã¯ onResults ã§ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’å‹•çš„ã«æ›´æ–°ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯åˆæœŸã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’ä½¿ç”¨
            const initialWristGeometry = new THREE.CylinderGeometry(1.0, 1.0, 1, MESH_SEGMENTS);
            
            // ãƒ¡ã‚¤ãƒ³ (flatMaterial ã‚’ä½¿ç”¨)
            hand.wristCylinder = new THREE.Mesh(initialWristGeometry.clone(), flatMaterial);
            hand.wristCylinder.visible = false;
            hand.wristCylinder.renderOrder = 1; // ãƒ¡ã‚¤ãƒ³ã‚’å¾Œã«æç”»
            scene.add(hand.wristCylinder);
            
            // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ (é»’)
            hand.outlineWristCylinder = new THREE.Mesh(initialWristGeometry.clone(), blackOutlineMaterial);
            hand.outlineWristCylinder.visible = false;
            hand.outlineWristCylinder.renderOrder = 0; // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã‚’å…ˆã«æç”»
            scene.add(hand.outlineWristCylinder);
            
            // 5. Initialize palm mesh (custom geometry)
            const initialPalmGeometry = new THREE.BufferGeometry();
            // æ‰‹ã®ã²ã‚‰å°‚ç”¨ãƒãƒ†ãƒªã‚¢ãƒ«(flatPalmMaterial)ã‚’å‰²ã‚Šå½“ã¦
            hand.palmMesh = new THREE.Mesh(initialPalmGeometry, flatPalmMaterial);
            hand.palmMesh.visible = false;
            hand.palmMesh.renderOrder = 1; // ãƒ¡ã‚¤ãƒ³ã‚’å¾Œã«æç”» (ä»–ã®ãƒ”ãƒ³ã‚¯éƒ¨åˆ†ã¨åŒã˜)
            scene.add(hand.palmMesh);
            
            // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ (é»’)
            hand.outlinePalmMesh = new THREE.Mesh(initialPalmGeometry, blackOutlineMaterial);
            hand.outlinePalmMesh.visible = false;
            hand.outlinePalmMesh.renderOrder = 0; // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã‚’å…ˆã«æç”»
            hand.outlinePalmMesh.scale.setScalar(PALM_OUTLINE_SCALE); 
            scene.add(hand.outlinePalmMesh);


            // Initialize smoothing array
            for(let i=0; i<21; i++) {
                hand.smoothedLandmarks.push(null);
            }

            return hand;
        }

        function initThreeJS() {
            scene = new THREE.Scene();

            // Background color set to pure green for chromakey
            scene.background = new THREE.Color(0x00ff00); 

            // Camera setup (Orthographic for 2D/stylized look)
            const aspect = window.innerWidth / window.innerHeight;
            const size = 15; 
            camera = new THREE.OrthographicCamera(
                -size * aspect / 2, size * aspect / 2, 
                size / 2, -size / 2, 
                0.1, 1000
            );
            camera.position.z = 10;
            camera.position.y = 5;
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('threeDCanvas') });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // renderOrder ã‚’æœ‰åŠ¹ã«ã™ã‚‹
            renderer.sortObjects = true; 

            handMeshes.push(createHandMeshes());
            handMeshes.push(createHandMeshes());
        }

        function resizeRenderer() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            renderer.setSize(width, height);
            
            const aspect = width / height;
            const size = 15;
            camera.left = -size * aspect / 2;
            camera.right = size * aspect / 2;
            camera.top = size / 2;
            camera.bottom = -size / 2;
            camera.updateProjectionMatrix();
        }

        window.addEventListener('resize', resizeRenderer);
        initThreeJS();
        
        // --- MediaPipe Hands Setup ---
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2, 
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // --- Camera Setup ---
        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
                
                const videoElement = document.createElement('video');
                videoElement.srcObject = stream;
                videoElement.play(); 

                await new Promise((resolve) => {
                    videoElement.onloadeddata = resolve;
                });

                messageBox.innerHTML = 'âœ¨ ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ä¸­...æ‰‹ã‚’ã‚«ãƒ¡ãƒ©ã«ã‹ã–ã—ã¦ãã ã•ã„ã€‚';
                messageBox.style.backgroundColor = 'rgba(191, 219, 254, 0.9)';
                messageBox.style.color = '#1e40af';
                
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: videoElement.videoWidth,
                    height: videoElement.videoHeight
                });
                camera.start();

            } catch (error) {
                console.error("Webã‚«ãƒ¡ãƒ©ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚", error);
                messageBox.innerHTML = 'ğŸš¨ ã‚¨ãƒ©ãƒ¼: ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ¨©é™ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
                messageBox.style.backgroundColor = 'rgba(254, 202, 202, 0.9)';
                messageBox.color = '#991b1b';
            }
        }

        /**
         * Processes MediaPipe results and updates the 3D model.
         * @param {object} results - MediaPipe Hands result object
         */
        function onResults(results) {
            const detectedHandsCount = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;

            for (let i = 0; i < handMeshes.length; i++) {
                const hand = handMeshes[i];

                if (i < detectedHandsCount) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handednessLabel = results.multiHandedness[i].label;
                    
                    // 1. Calculate landmark positions and apply smoothing 
                    landmarks.forEach((landmark, j) => {
                        let x = (landmark.x - 0.5) * worldScale * -1; 
                        const y = (landmark.y - 0.5) * worldScale * -1; 
                        const z = landmark.z * worldScale * -1; 

                        const currentPos = new THREE.Vector3(x, y, z);

                        if (hand.smoothedLandmarks[j]) {
                            hand.smoothedLandmarks[j].lerp(currentPos, smoothingFactor);
                        } else {
                            hand.smoothedLandmarks[j] = currentPos;
                        }
                        landmarks[j].position3D = hand.smoothedLandmarks[j]; 
                    });
                    
                    // --- Dynamic Thickness Calculation ---
                    const v0 = landmarks[0].position3D; 
                    const v5 = landmarks[5].position3D;
                    const v9 = landmarks[9].position3D;
                    const v17 = landmarks[17].position3D;

                    const metacarpalWidth = v5.distanceTo(v9); 

                    const baseThickness = metacarpalWidth * FINGER_THICKNESS_RATIO;
                    const wristThickness = metacarpalWidth * WRIST_THICKNESS_RATIO; 
                    const L0_EMPHASIS_FACTOR = 2.5;     // æ‰‹é¦–ã®çƒä½“ã®å¤ªã•
                    
                    // --- MISSING DEFINITION FIX: L0_Radius (æ‰‹é¦–ã®ä»˜ã‘æ ¹ã®çƒä½“ã®åŠå¾„) ã®å®šç¾©ã‚’è¿½åŠ  ---
                    const L0_Radius = baseThickness * L0_EMPHASIS_FACTOR; 
                    // -------------------------------------------------------------------------
                    
                    const extraDotThickness = metacarpalWidth * EXTRA_DOT_THICKNESS_RATIO; 
                    // -------------------------------------

                    // --- è…•ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªã®å‹•çš„æ›´æ–°ï¼ˆè‡ªç„¶ãªæ‰‹é¦–ã®æ¥ç¶šã®ãŸã‚ï¼‰ ---
                    
                    // ãƒ¡ã‚¤ãƒ³ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®å¤ªã•
                    const topRadius = wristThickness; // è…•ã®é ã„å´ (Top): 1.2å€
                    const bottomRadius = L0_Radius * 0.95; // æ‰‹é¦–ã®ä»˜ã‘æ ¹å´ (Bottom): L0ã®çƒä½“ã¨ã»ã¼åŒã˜å¤ªã•

                    // ãƒ¡ã‚¤ãƒ³ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªæ›´æ–°
                    // CylinderGeometry(radiusTop, radiusBottom, height, ...)
                    const newWristGeometry = new THREE.CylinderGeometry(
                        topRadius, 
                        bottomRadius, 
                        1, // é«˜ã•
                        MESH_SEGMENTS,
                        1,
                        false // openEnded
                    );
                    
                    // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®å¤ªã•è¨ˆç®—
                    const outlineTopRadius = topRadius * OUTLINE_SCALE_FACTOR * OUTLINE_TAPER_FACTOR; 
                    const outlineBottomRadius = (bottomRadius * OUTLINE_SCALE_FACTOR); 

                    // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªæ›´æ–°
                    const newOutlineWristGeometry = new THREE.CylinderGeometry(
                        outlineTopRadius, 
                        outlineBottomRadius, 
                        1, // é«˜ã•
                        MESH_SEGMENTS,
                        1,
                        false // openEnded
                    );

                    // ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’æ›´æ–°ï¼ˆæ–°ã—ã„ã‚‚ã®ã‚’é©ç”¨ã—ã€å¤ã„ã‚‚ã®ã‚’disposeï¼‰
                    if (hand.wristCylinder.geometry) hand.wristCylinder.geometry.dispose();
                    hand.wristCylinder.geometry = newWristGeometry;
                    
                    if (hand.outlineWristCylinder.geometry) hand.outlineWristCylinder.geometry.dispose();
                    hand.outlineWristCylinder.geometry = newOutlineWristGeometry;
                    // -----------------------------------------------------

                    
                    // 2. Update joint spheres (Spheres) position and size
                    landmarks.forEach((landmark, j) => {
                        const sphere = hand.spheres[j];
                        const outlineSphere = hand.outlineSpheres[j];
                        
                        sphere.position.copy(landmark.position3D);
                        outlineSphere.position.copy(landmark.position3D); // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã‚‚åŒã˜ä½ç½®
                        
                        let currentRadius;
                        let outlineScale;

                        if (j === 0) {
                            // L0 (æ‰‹é¦–ã®ä»˜ã‘æ ¹)
                            currentRadius = L0_Radius; // ãƒ¡ã‚¤ãƒ³ãƒœãƒ‡ã‚£ã®åŠå¾„
                            outlineScale = L0_OUTLINE_THICKNESS_SCALE; // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã®å€ç‡ (1.03)
                        } else if (TIP_LANDMARKS.includes(j)) {
                            // æŒ‡å…ˆ (4, 8, 12, 16, 20)
                            currentRadius = baseThickness * TIP_RADIUS_FACTOR; // <<< ä¿®æ­£ã•ã‚ŒãŸ 0.8 ãŒé©ç”¨ >>>
                            outlineScale = OUTLINE_SCALE_FACTOR; // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã®å€ç‡ (1.07)
                        } else if (BASE_JOINT_LANDMARKS.includes(j)) { 
                            // æŒ‡ã®ä»˜ã‘æ ¹ã®é–¢ç¯€ (L1, L5, L9, L13, L17)
                            currentRadius = baseThickness * JOINT_RADIUS_FACTOR;
                            outlineScale = OUTLINE_SCALE_FACTOR; // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã®å€ç‡ (1.07)
                        } else {
                            // æŒ‡ã®ãã®ä»–ã®é–¢ç¯€ (L2, L3, L6, L7...)
                            currentRadius = baseThickness * JOINT_RADIUS_FACTOR;
                            // å¼·èª¿ã—ãŸã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ (1.1235) ã‚’é©ç”¨
                            outlineScale = OUTLINE_SCALE_FACTOR * JOINT_OUTLINE_BOOST; 
                        }

                        // ãƒ¡ã‚¤ãƒ³ãƒœãƒ‡ã‚£
                        sphere.scale.setScalar(currentRadius);
                        sphere.visible = true; 

                        // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ (è£é¢æç”»ã¨åˆã‚ã›ã¦ã€å¤ªã•ã‚’å¼·èª¿)
                        outlineSphere.scale.setScalar(currentRadius * outlineScale);
                        outlineSphere.visible = true;
                    });
                    
                    // 3. Update bone cylinders (Cylinders) position, rotation, and scale
                    hand.cylinders.forEach((cylinder, j) => {
                        const [startIdx, endIdx] = BONE_CONNECTIONS[j];
                        const startPos = landmarks[startIdx].position3D;
                        const endPos = landmarks[endIdx].position3D;     
                        
                        const outlineCylinder = hand.outlineCylinders[j];

                        if (startPos && endPos) {
                            const distance = startPos.distanceTo(endPos);
                            const midPoint = new THREE.Vector3().lerpVectors(startPos, endPos, 0.5);

                            let thickness = baseThickness;
                            if (THUMB_LANDMARKS.includes(startIdx) || THUMB_LANDMARKS.includes(endIdx)) {
                                thickness *= 1.1; 
                            }

                            // ãƒ¡ã‚¤ãƒ³ãƒœãƒ‡ã‚£
                            cylinder.position.copy(midPoint);
                            cylinder.scale.set(thickness, distance, thickness); 
                            cylinder.visible = true; 

                            // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ (éª¨ã®ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã¯æ¨™æº–å€ç‡ã‚’ç¶­æŒ: 1.07)
                            outlineCylinder.position.copy(midPoint);
                            outlineCylinder.scale.set(thickness * OUTLINE_SCALE_FACTOR, distance * OUTLINE_SCALE_FACTOR, thickness * OUTLINE_SCALE_FACTOR); 
                            outlineCylinder.visible = true;
                            
                            const orientation = new THREE.Vector3().subVectors(endPos, startPos).normalize();
                            const up = new THREE.Vector3(0, 1, 0); 
                            
                            cylinder.quaternion.setFromUnitVectors(up, orientation);
                            outlineCylinder.quaternion.setFromUnitVectors(up, orientation);

                        } else {
                            cylinder.visible = false; 
                            outlineCylinder.visible = false;
                        }
                    });

                    // 4. Update wrist cylinder (with offset)
                    const v9_for_wrist_dir = landmarks[9].position3D; 

                    if (v0 && v9_for_wrist_dir) {
                        const handDirection = new THREE.Vector3().subVectors(v0, v9_for_wrist_dir).normalize();
                        let xOffsetFactor = 0; 
                        if (handednessLabel === 'Right') {
                            xOffsetFactor = 1;
                        } else if (handednessLabel === 'Left') {
                            xOffsetFactor = -1;
                        }

                        // === 1. ãƒ”ãƒ³ã‚¯ã®ãƒ¡ã‚¤ãƒ³ã‚·ãƒªãƒ³ãƒ€ãƒ¼ (é•·ã„) ===
                        const longWristLength = worldScale * wristLengthFactor; // 0.9 (é•·ã„)
                        const longWristEnd = v0.clone().add(handDirection.clone().multiplyScalar(longWristLength));
                        const longDistance = longWristEnd.distanceTo(v0);
                        const longMidPoint = new THREE.Vector3().lerpVectors(v0, longWristEnd, 0.5);
                        longMidPoint.x += wristOffsetX * xOffsetFactor; 

                        const wristCylinder = hand.wristCylinder;
                        wristCylinder.position.copy(longMidPoint);
                        // ã‚¹ã‚±ãƒ¼ãƒ«ã¯(1, é•·ã•, 1)ã§ã€å¤ªã•ã¯ã‚¸ã‚ªãƒ¡ãƒˆãƒªã§åˆ¶å¾¡
                        wristCylinder.scale.set(1, longDistance, 1); 
                        wristCylinder.visible = true;
                        
                        // === 2. é»’ã„ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã‚·ãƒªãƒ³ãƒ€ãƒ¼ (çŸ­ã„ & ã‚ªãƒ•ã‚»ãƒƒãƒˆ) ===
                        const shortWristLength = worldScale * outlineWristLengthFactor; // 6.0 å˜ä½
                        
                        const startOffset = worldScale * outlineWristStartOffsetFactor; 

                        // å®Ÿéš›ã®ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®é•·ã• 
                        const actualLength = Math.max(0.01, shortWristLength - startOffset); 

                        // æ–°ã—ã„é–‹å§‹ç‚¹: L0ã‹ã‚‰è…•ã®æ–¹å‘ã«ãšã‚‰ã™
                        const outlineStartPoint = v0.clone().add(handDirection.clone().multiplyScalar(startOffset));
                        // æ–°ã—ã„çµ‚äº†ç‚¹: æ–°ã—ã„é–‹å§‹ç‚¹ã‹ã‚‰å®Ÿéš›ã®é•·ã•ã ã‘ä¼¸ã°ã™
                        const shortWristEnd = outlineStartPoint.clone().add(handDirection.clone().multiplyScalar(actualLength));

                        const shortDistance = shortWristEnd.distanceTo(outlineStartPoint);
                        const shortMidPoint = new THREE.Vector3().lerpVectors(outlineStartPoint, shortWristEnd, 0.5);
                        shortMidPoint.x += wristOffsetX * xOffsetFactor; 

                        const outlineWristCylinder = hand.outlineWristCylinder;
                        outlineWristCylinder.position.copy(shortMidPoint);
                        // ã‚¹ã‚±ãƒ¼ãƒ«ã¯(1, é•·ã•, 1)ã§ã€å¤ªã•ã¯ã‚¸ã‚ªãƒ¡ãƒˆãƒªã§åˆ¶å¾¡
                        outlineWristCylinder.scale.set(1, shortDistance, 1); 
                        outlineWristCylinder.visible = true; 
                        
                        // å›è»¢ã¯ã©ã¡ã‚‰ã®ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã«ã‚‚é©ç”¨
                        const orientation = new THREE.Vector3().subVectors(longWristEnd, v0).normalize();
                        const up = new THREE.Vector3(0, 1, 0); 

                        wristCylinder.quaternion.setFromUnitVectors(up, orientation);
                        outlineWristCylinder.quaternion.setFromUnitVectors(up, orientation);
                    } else {
                        hand.wristCylinder.visible = false;
                        hand.outlineWristCylinder.visible = false;
                    }

                    // 5. Update the extra wrist dot (extraWristDot) - No outline for this
                    if (v0 && v17) {
                        // Position slightly outside (L17 side) on the L0-L17 line
                        const wristDotPos = new THREE.Vector3().lerpVectors(v0, v17, 0.65); 
                        
                        hand.extraWristDot.position.copy(wristDotPos);
                        hand.extraWristDot.scale.setScalar(extraDotThickness);
                        hand.extraWristDot.visible = true;
                    } else {
                        hand.extraWristDot.visible = false;
                    }
                    
                    // 6. Update palm mesh 
                    const v1 = landmarks[1].position3D; 
                    const v2 = landmarks[2].position3D; 
                    const v13 = landmarks[13].position3D; 
                    
                    const outlinePalmMesh = hand.outlinePalmMesh;

                    if (v0 && v1 && v2 && v5 && v9 && v13 && v17) {
                        // Float32Array ã«ä¿®æ­£æ¸ˆã¿
                        const vertices_palm = new Float32Array([
                            v0.x, v0.y, v0.z,       
                            v1.x, v1.y, v1.z,       
                            v2.x, v2.y, v2.z,       
                            v5.x, v5.y, v5.z,       
                            v9.x, v9.y, v9.z,       
                            v13.x, v13.y, v13.z,    
                            v17.x, v17.y, v17.z     
                        ]);
                        
                        const indices = new Uint16Array([
                            0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5, 0, 5, 6, 0, 6, 1  
                        ]);

                        // --- ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒƒã‚·ãƒ¥ã®æ›´æ–° ---
                        const geometry = hand.palmMesh.geometry;
                        let positionAttribute = geometry.getAttribute('position');
                        
                        if (positionAttribute && positionAttribute.count === 7) { 
                            positionAttribute.set(vertices_palm);
                            positionAttribute.needsUpdate = true;
                        } else {
                            positionAttribute = new THREE.BufferAttribute(vertices_palm, 3);
                            geometry.setAttribute('position', positionAttribute);
                        }
                        
                        if (geometry.index === null || geometry.index.count !== indices.length) {
                            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
                        }
                        hand.palmMesh.visible = true;
                        
                        // --- ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ãƒ¡ãƒƒã‚·ãƒ¥ã®æ›´æ–° ---
                        const outlineGeometry = outlinePalmMesh.geometry;
                        
                        let outlinePositionAttribute = outlineGeometry.getAttribute('position');
                        if (outlinePositionAttribute && outlinePositionAttribute.count === 7) { 
                            outlinePositionAttribute.set(vertices_palm);
                            outlinePositionAttribute.needsUpdate = true;
                        } else {
                            outlinePositionAttribute = new THREE.BufferAttribute(vertices_palm, 3);
                            outlineGeometry.setAttribute('position', outlinePositionAttribute);
                        }

                        if (outlineGeometry.index === null || outlineGeometry.index.count !== indices.length) {
                             outlineGeometry.setIndex(new THREE.BufferAttribute(indices, 1));
                        }
                        // ã‚¹ã‚±ãƒ¼ãƒ«ã¯createHandMeshesã§è¨­å®šæ¸ˆã¿ã®ãŸã‚ã€ã“ã“ã§ã¯æ›´æ–°ä¸è¦
                        outlinePalmMesh.visible = true;
                        
                    } else {
                        hand.palmMesh.visible = false;
                        outlinePalmMesh.visible = false;

                    }
                    
                    hand.isVisible = true;

                } else {
                    // Hide all elements when not detected
                    if (hand.isVisible) {
                        // ãƒ¡ã‚¤ãƒ³ãƒœãƒ‡ã‚£
                        hand.spheres.forEach(s => s.visible = false);
                        hand.cylinders.forEach(c => c.visible = false);
                        hand.wristCylinder.visible = false;
                        hand.palmMesh.visible = false;
                        hand.extraWristDot.visible = false;
                        
                        // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³
                        hand.outlineSpheres.forEach(s => s.visible = false);
                        hand.outlineCylinders.forEach(c => c.visible = false);
                        hand.outlineWristCylinder.visible = false;
                        hand.outlinePalmMesh.visible = false;
                        
                        hand.isVisible = false;
                    }
                }
            }

            renderer.render(scene, camera);
        }
        
        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Start camera and tracking on window load
        window.onload = function () {
            resizeRenderer();
            setupCamera();
            animate();
        }
    </script>
</body>
</html>
