<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Mayatete (Chromakey)</title>

    <!-- Tailwind CSSã®èª­ã¿è¾¼ã¿ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.jsã®èª­ã¿è¾¼ã¿ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Handsã®èª­ã¿è¾¼ã¿ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>
    <!-- MediaPipe CameraUtils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7fafc;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #threeDContainer {
            width: 100vw;
            height: 100vh;
        }
        #threeDCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

    <!-- 3Dãƒ¢ãƒ‡ãƒ«ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã®ã‚³ãƒ³ãƒ†ãƒŠã®ã¿ -->
    <div id="threeDContainer">
        <canvas id="threeDCanvas"></canvas>
    </div>

    <!-- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ -->
    <div id="messageBox" class="rounded-lg shadow-lg" style="position:fixed; top:10px; left:50%; transform:translateX(-50%); z-index:10; padding: 10px; background: rgba(255, 255, 255, 0.9); border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">
        ã‚«ãƒ¡ãƒ©ã®èµ·å‹•ã‚’å¾…ã£ã¦ã„ã¾ã™...
    </div>

    <script>
        // MediaPipe Handsã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯æ¥ç¶šå®šç¾© (ãƒ¡ãƒƒã‚·ãƒ¥ç”¨)
        const HAND_BONE_PAIRS = [
            // Fingers
            [0, 1], [1, 2], [2, 3], [3, 4],
            [5, 6], [6, 7], [7, 8],
            [9, 10], [10, 11], [11, 12],
            [13, 14], [14, 15], [15, 16],
            [17, 18], [18, 19], [19, 20],

            // Metacarpals
            [0, 5], [0, 9], [0, 13], [0, 17],
            [5, 9], [9, 13], [13, 17]
        ];

        // Thumb indices
        const THUMB_INDICES = [0, 1, 2, 3, 4];

        // æŒ‡å…ˆã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ID
        const TIP_INDICES = [4, 8, 12, 16, 20];
        // æŒ‡ã®ä»˜ã‘æ ¹ï¼ˆæ‰‹ã®ã²ã‚‰ã«æ¥ã™ã‚‹éƒ¨åˆ†ï¼‰ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ID
        const BASE_JOINT_INDICES = [1, 5, 9, 13, 17];

        // å…±é€šã®å¤ªã•èª¿æ•´å®šæ•°
        const JOINT_RADIUS_MULTIPLIER = 0.8; // ä»–ã®é–¢ç¯€ã®åŸºæœ¬å€ç‡
        const TIP_RADIUS_MULTIPLIER = 0.8;   // æŒ‡å…ˆã®å¤ªã•ãƒ–ãƒ¼ã‚¹ãƒˆ

        // --- UI elements ---
        const uiMessageBox = document.getElementById('messageBox');

        // --- Three.js Setup ---
        let threeScene, threeCamera, threeRenderer;
        const hands3D = [];

        // è‚Œã®è‰² (æŒ‡å®šã•ã‚ŒãŸè‰²)
        const SKIN_COLOR = 0xFFEEE2;
        // ç·šã®è‰²ã‚’å¤‰æ›´ (æŒ‡å®šã•ã‚ŒãŸè‰²)
        const OUTLINE_COLOR = 0x5A4F47;

        // 1. ãƒ¡ã‚¤ãƒ³ã®ã‚½ãƒªãƒƒãƒ‰ãƒœãƒ‡ã‚£ç”¨ãƒãƒ†ãƒªã‚¢ãƒ« (æŒ‡ã€é–¢ç¯€ã€æ‰‹é¦–ç”¨)
        const skinMaterial = new THREE.MeshBasicMaterial({
            color: SKIN_COLOR,
            side: THREE.DoubleSide,
            polygonOffset: true,
            polygonOffsetFactor: -10.0,
            polygonOffsetUnits: -10.0
        });

        // 1b. æ‰‹ã®ã²ã‚‰å°‚ç”¨ãƒãƒ†ãƒªã‚¢ãƒ« (Z-fightingå¯¾ç­–)
        const palmMaterial = new THREE.MeshBasicMaterial({
            color: SKIN_COLOR,
            side: THREE.DoubleSide,
            polygonOffset: true,
            polygonOffsetFactor: -50.0,
            polygonOffsetUnits: -50.0
        });

        // 2. ã‚·ãƒ«ã‚¨ãƒƒãƒˆã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ç”¨ãƒãƒ†ãƒªã‚¢ãƒ« (æŒ‡å®šã•ã‚ŒãŸè‰²ã€è£é¢ã®ã¿æç”»)
        const outlineMaterial = new THREE.MeshBasicMaterial({
            color: OUTLINE_COLOR,
            side: THREE.BackSide,
            polygonOffset: true,
            polygonOffsetFactor: 5.0,
            polygonOffsetUnits: 5.0
        });

        // Mesh resolution (segments)
        const MESH_SEGMENT_COUNT = 32;

        // Scaling factor for MediaPipe coordinates in 3D space
        const WORLD_SCALE = 10;

        // Smoothing settings
        const SMOOTHING_FACTOR = 0.4;

        // Thickness ratios
        const FINGER_THICKNESS_RATIO = 0.40;

        // æ‰‹é¦–ã®å¤ªã•ã®å€ç‡
        const WRIST_THICKNESS_RATIO = 1.2;  // è…•ã®é ã„å´ã®å¤ªã•ã®ãƒ™ãƒ¼ã‚¹
        const L0_RADIUS_EMPHASIS = 2.5;     // æ‰‹é¦–ã®çƒä½“ã®å¤ªã•ï¼ˆå¼·èª¿ä¿‚æ•°ï¼‰

        const EXTRA_WRIST_DOT_RATIO = 0.30; // Thickness of the extra wrist dot

        // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã®ç´°ã•èª¿æ•´
        const OUTLINE_SCALE = 1.07; // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã®å¤ªã• (åŸºæœ¬å€ç‡: éª¨ã€æŒ‡å…ˆã€æŒ‡ã®ä»˜ã‘æ ¹ã«é©ç”¨)
        const L0_OUTLINE_SCALE = 1.03; // L0 (æ‰‹é¦–ã®çƒä½“) å°‚ç”¨ã®ç´°ã„ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³å€ç‡
        const PALM_OUTLINE_SCALE = 1.03; // æ‰‹ã®ã²ã‚‰ãƒ¡ãƒƒã‚·ãƒ¥å°‚ç”¨ã®ç´°ã„ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³å€ç‡

        // æŒ‡ã®é–¢ç¯€ã ã‘ã‚’å¤ªãã™ã‚‹ãƒ–ãƒ¼ã‚¹ãƒˆä¿‚æ•° (L0, æŒ‡å…ˆ, æŒ‡ã®ä»˜ã‘æ ¹ä»¥å¤–ã«é©ç”¨)
        const JOINT_OUTLINE_BOOST = 1.05;

        const WRIST_OFFSET_X = 0.1; // X-axis offset for the wrist cylinder

        // [è…•ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®é•·ã•è¨­å®š]
        const WRIST_LONG_LENGTH_FACTOR = 0.9; // ãƒ”ãƒ³ã‚¯ã®ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®é•·ã• (é•·ã„)
        const WRIST_OUTLINE_SHORT_LENGTH_FACTOR = 0.60; // é»’ã„ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ç”¨ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®é•·ã•

        // [é»’ã„ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆè¨­å®š]
        const OUTLINE_WRIST_START_OFFSET_FACTOR = 0.08;

        // è…•ã®é ã„å´ã®ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã‚’ç´°ãã™ã‚‹ãƒ†ãƒ¼ãƒ‘ãƒ¼ä¿‚æ•°
        const OUTLINE_TAPER_FACTOR = 0.85;

        /**
         * Creates all meshes and objects for a single hand.
         * @returns {object} Hand object containing meshes and state
         */
        function createHandObjects() {
            const handObj = {
                // ãƒ¡ã‚¤ãƒ³ãƒœãƒ‡ã‚£
                jointMeshes: [],
                boneMeshes: [],
                armMainCylinder: null,
                palmMesh: null,
                extraWristDot: null, // è‚Œè‰²ã®ç‚¹

                // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ç”¨ãƒ¡ãƒƒã‚·ãƒ¥
                outlineJointMeshes: [],
                outlineBoneMeshes: [],
                outlineArmCylinder: null,
                outlinePalmMesh: null,

                smoothedPositions: [],
                isVisible: false
            };

            // === Mesh elements creation ===
            const sphereGeom = new THREE.SphereGeometry(1.0, MESH_SEGMENT_COUNT, MESH_SEGMENT_COUNT);
            const cylinderGeom = new THREE.CylinderGeometry(1.0, 1.0, 1, MESH_SEGMENT_COUNT);

            // 1. Create all joint spheres (21 points)
            for (let i = 0; i < 21; i++) {
                // ãƒ¡ã‚¤ãƒ³ (skinMaterial ã‚’ä½¿ç”¨)
                const jointMesh = new THREE.Mesh(sphereGeom, skinMaterial);
                jointMesh.visible = false;
                jointMesh.renderOrder = 1; // ãƒ¡ã‚¤ãƒ³ã‚’å¾Œã«æç”»
                threeScene.add(jointMesh);
                handObj.jointMeshes.push(jointMesh);

                // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ (outlineMaterial)
                const outlineJointMesh = new THREE.Mesh(sphereGeom, outlineMaterial);
                outlineJointMesh.visible = false;
                outlineJointMesh.renderOrder = 0; // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã‚’å…ˆã«æç”»
                threeScene.add(outlineJointMesh);
                handObj.outlineJointMeshes.push(outlineJointMesh);
            }

            // 2. Create the extra wrist dot (ãƒ¡ã‚¤ãƒ³ã®ã¿, skinMaterial ã‚’ä½¿ç”¨)
            handObj.extraWristDot = new THREE.Mesh(sphereGeom, skinMaterial);
            handObj.extraWristDot.visible = false;
            handObj.extraWristDot.renderOrder = 1;
            threeScene.add(handObj.extraWristDot);

            // 3. Create all bone cylinders (HAND_BONE_PAIRS count)
            HAND_BONE_PAIRS.forEach(() => {
                // ãƒ¡ã‚¤ãƒ³ (skinMaterial ã‚’ä½¿ç”¨)
                const boneMesh = new THREE.Mesh(cylinderGeom, skinMaterial);
                boneMesh.visible = false;
                boneMesh.renderOrder = 1;
                threeScene.add(boneMesh);
                handObj.boneMeshes.push(boneMesh);

                // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ (outlineMaterial)
                const outlineBoneMesh = new THREE.Mesh(cylinderGeom, outlineMaterial);
                outlineBoneMesh.visible = false;
                outlineBoneMesh.renderOrder = 0;
                threeScene.add(outlineBoneMesh);
                handObj.outlineBoneMeshes.push(outlineBoneMesh);
            });

            // 4. Initialize wrist (arm) cylinder
            const initialArmCylinderGeom = new THREE.CylinderGeometry(1.0, 1.0, 1, MESH_SEGMENT_COUNT);

            handObj.armMainCylinder = new THREE.Mesh(initialArmCylinderGeom.clone(), skinMaterial);
            handObj.armMainCylinder.visible = false;
            handObj.armMainCylinder.renderOrder = 1;
            threeScene.add(handObj.armMainCylinder);

            handObj.outlineArmCylinder = new THREE.Mesh(initialArmCylinderGeom.clone(), outlineMaterial);
            handObj.outlineArmCylinder.visible = false;
            handObj.outlineArmCylinder.renderOrder = 0;
            threeScene.add(handObj.outlineArmCylinder);

            // 5. Initialize palm mesh (custom geometry)
            const initialPalmGeom = new THREE.BufferGeometry();
            handObj.palmMesh = new THREE.Mesh(initialPalmGeom, palmMaterial);
            handObj.palmMesh.visible = false;
            handObj.palmMesh.renderOrder = 1;
            threeScene.add(handObj.palmMesh);

            handObj.outlinePalmMesh = new THREE.Mesh(initialPalmGeom, outlineMaterial);
            handObj.outlinePalmMesh.visible = false;
            handObj.outlinePalmMesh.renderOrder = 0;
            handObj.outlinePalmMesh.scale.setScalar(PALM_OUTLINE_SCALE);
            threeScene.add(handObj.outlinePalmMesh);

            // Initialize smoothing array
            for (let i = 0; i < 21; i++) {
                handObj.smoothedPositions.push(null);
            }

            return handObj;
        }

        function initThreeScene() {
            threeScene = new THREE.Scene();

            // Background color set to pure green for chromakey
            threeScene.background = new THREE.Color(0x00ff00);

            // Camera setup (Orthographic for 2D/stylized look)
            const aspect = window.innerWidth / window.innerHeight;
            const size = 15;
            threeCamera = new THREE.OrthographicCamera(
                -size * aspect / 2, size * aspect / 2,
                size / 2, -size / 2,
                0.1, 1000
            );
            threeCamera.position.z = 10;
            threeCamera.position.y = 5;
            threeCamera.lookAt(0, 0, 0);

            threeRenderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('threeDCanvas') });
            threeRenderer.setSize(window.innerWidth, window.innerHeight);
            threeRenderer.setPixelRatio(window.devicePixelRatio);

            // renderOrder ã‚’æœ‰åŠ¹ã«ã™ã‚‹
            threeRenderer.sortObjects = true;

            hands3D.push(createHandObjects());
            hands3D.push(createHandObjects());
        }

        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            threeRenderer.setSize(width, height);

            const aspect = width / height;
            const size = 15;
            threeCamera.left = -size * aspect / 2;
            threeCamera.right = size * aspect / 2;
            threeCamera.top = size / 2;
            threeCamera.bottom = -size / 2;
            threeCamera.updateProjectionMatrix();
        }

        window.addEventListener('resize', onWindowResize);
        initThreeScene();

        // --- MediaPipe Hands Setup ---
        const hands = new Hands({ locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(handleHandsResults);

        // --- Camera Setup ---
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });

                const videoElement = document.createElement('video');
                videoElement.srcObject = stream;
                videoElement.play();

                await new Promise((resolve) => {
                    videoElement.onloadeddata = resolve;
                });

                uiMessageBox.innerHTML = 'âœ¨ ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ä¸­...æ‰‹ã‚’ã‚«ãƒ¡ãƒ©ã«ã‹ã–ã—ã¦ãã ã•ã„ã€‚';
                uiMessageBox.style.backgroundColor = 'rgba(191, 219, 254, 0.9)';
                uiMessageBox.style.color = '#1e40af';

                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({ image: videoElement });
                    },
                    width: videoElement.videoWidth,
                    height: videoElement.videoHeight
                });
                camera.start();

            } catch (error) {
                console.error("Webã‚«ãƒ¡ãƒ©ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚", error);
                uiMessageBox.innerHTML = 'ğŸš¨ ã‚¨ãƒ©ãƒ¼: ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ¨©é™ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
                uiMessageBox.style.backgroundColor = 'rgba(254, 202, 202, 0.9)';
                uiMessageBox.color = '#991b1b';
            }
        }

        /**
         * Processes MediaPipe results and updates the 3D model.
         * @param {object} results - MediaPipe Hands result object
         */
        function handleHandsResults(results) {
            const detectedCount = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;

            for (let i = 0; i < hands3D.length; i++) {
                const hand = hands3D[i];

                if (i < detectedCount) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handednessLabel = results.multiHandedness[i].label;

                    // 1. Calculate landmark positions and apply smoothing
                    landmarks.forEach((landmark, j) => {
                        let x = (landmark.x - 0.5) * WORLD_SCALE * -1;
                        const y = (landmark.y - 0.5) * WORLD_SCALE * -1;
                        const z = landmark.z * WORLD_SCALE * -1;

                        const currentPos = new THREE.Vector3(x, y, z);

                        if (hand.smoothedPositions[j]) {
                            hand.smoothedPositions[j].lerp(currentPos, SMOOTHING_FACTOR);
                        } else {
                            hand.smoothedPositions[j] = currentPos;
                        }
                        landmarks[j].position3D = hand.smoothedPositions[j];
                    });

                    // --- Dynamic Thickness Calculation ---
                    const lm0 = landmarks[0].position3D;
                    const lm5 = landmarks[5].position3D;
                    const lm9 = landmarks[9].position3D;
                    const lm17 = landmarks[17].position3D;

                    const metacarpalDistance = lm5.distanceTo(lm9);

                    const baseThickness = metacarpalDistance * FINGER_THICKNESS_RATIO;
                    const wristThickness = metacarpalDistance * WRIST_THICKNESS_RATIO;
                    const L0_RADIUS_EMPHASIS = 2.5; // æ‰‹é¦–ã®çƒä½“ã®å¤ªã•ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«å®šç¾©ãƒ»å…ƒã‚³ãƒ¼ãƒ‰ã¨åŒæ§˜ã«ä¿æŒï¼‰

                    const L0_RADIUS = baseThickness * L0_RADIUS_EMPHASIS;

                    const extraDotThickness = metacarpalDistance * EXTRA_WRIST_DOT_RATIO;

                    // --- è…•ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªã®å‹•çš„æ›´æ–°ï¼ˆè‡ªç„¶ãªæ‰‹é¦–ã®æ¥ç¶šã®ãŸã‚ï¼‰ ---

                    // ãƒ¡ã‚¤ãƒ³ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®å¤ªã•
                    const topRadius = wristThickness; // è…•ã®é ã„å´ (Top)
                    const bottomRadius = L0_RADIUS * 0.95; // æ‰‹é¦–ã®ä»˜ã‘æ ¹å´ (Bottom)

                    // ãƒ¡ã‚¤ãƒ³ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªæ›´æ–°
                    const newArmCylinderGeom = new THREE.CylinderGeometry(
                        topRadius,
                        bottomRadius,
                        1, // é«˜ã•
                        MESH_SEGMENT_COUNT,
                        1,
                        false
                    );

                    // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã®å¤ªã•è¨ˆç®—
                    const outlineTopRadius = topRadius * OUTLINE_SCALE * OUTLINE_TAPER_FACTOR;
                    const outlineBottomRadius = (bottomRadius * OUTLINE_SCALE);

                    const newOutlineArmCylinderGeom = new THREE.CylinderGeometry(
                        outlineTopRadius,
                        outlineBottomRadius,
                        1, // é«˜ã•
                        MESH_SEGMENT_COUNT,
                        1,
                        false
                    );

                    if (hand.armMainCylinder.geometry) hand.armMainCylinder.geometry.dispose();
                    hand.armMainCylinder.geometry = newArmCylinderGeom;

                    if (hand.outlineArmCylinder.geometry) hand.outlineArmCylinder.geometry.dispose();
                    hand.outlineArmCylinder.geometry = newOutlineArmCylinderGeom;

                    // 2. Update joint spheres (jointMeshes) position and size
                    landmarks.forEach((landmark, j) => {
                        const jointMesh = hand.jointMeshes[j];
                        const outlineJointMesh = hand.outlineJointMeshes[j];

                        jointMesh.position.copy(landmark.position3D);
                        outlineJointMesh.position.copy(landmark.position3D);

                        let currentRadius;
                        let outlineScale;

                        if (j === 0) {
                            // L0 (æ‰‹é¦–ã®ä»˜ã‘æ ¹)
                            currentRadius = L0_RADIUS;
                            outlineScale = L0_OUTLINE_SCALE;
                        } else if (TIP_INDICES.includes(j)) {
                            // æŒ‡å…ˆ
                            currentRadius = baseThickness * TIP_RADIUS_MULTIPLIER;
                            outlineScale = OUTLINE_SCALE;
                        } else if (BASE_JOINT_INDICES.includes(j)) {
                            // æŒ‡ã®ä»˜ã‘æ ¹
                            currentRadius = baseThickness * JOINT_RADIUS_MULTIPLIER;
                            outlineScale = OUTLINE_SCALE;
                        } else {
                            // æŒ‡ã®ãã®ä»–ã®é–¢ç¯€
                            currentRadius = baseThickness * JOINT_RADIUS_MULTIPLIER;
                            outlineScale = OUTLINE_SCALE * JOINT_OUTLINE_BOOST;
                        }

                        // ãƒ¡ã‚¤ãƒ³ãƒœãƒ‡ã‚£
                        jointMesh.scale.setScalar(currentRadius);
                        jointMesh.visible = true;

                        // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³
                        outlineJointMesh.scale.setScalar(currentRadius * outlineScale);
                        outlineJointMesh.visible = true;
                    });

                    // 3. Update bone cylinders (boneMeshes) position, rotation, and scale
                    hand.boneMeshes.forEach((boneMesh, j) => {
                        const [startIdx, endIdx] = HAND_BONE_PAIRS[j];
                        const startPos = landmarks[startIdx].position3D;
                        const endPos = landmarks[endIdx].position3D;

                        const outlineBoneMesh = hand.outlineBoneMeshes[j];

                        if (startPos && endPos) {
                            const distance = startPos.distanceTo(endPos);
                            const midPoint = new THREE.Vector3().lerpVectors(startPos, endPos, 0.5);

                            let thickness = baseThickness;
                            if (THUMB_INDICES.includes(startIdx) || THUMB_INDICES.includes(endIdx)) {
                                thickness *= 1.1;
                            }

                            // ãƒ¡ã‚¤ãƒ³ãƒœãƒ‡ã‚£
                            boneMesh.position.copy(midPoint);
                            boneMesh.scale.set(thickness, distance, thickness);
                            boneMesh.visible = true;

                            // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³
                            outlineBoneMesh.position.copy(midPoint);
                            outlineBoneMesh.scale.set(thickness * OUTLINE_SCALE, distance * OUTLINE_SCALE, thickness * OUTLINE_SCALE);
                            outlineBoneMesh.visible = true;

                            const orientation = new THREE.Vector3().subVectors(endPos, startPos).normalize();
                            const up = new THREE.Vector3(0, 1, 0);

                            boneMesh.quaternion.setFromUnitVectors(up, orientation);
                            outlineBoneMesh.quaternion.setFromUnitVectors(up, orientation);

                        } else {
                            boneMesh.visible = false;
                            outlineBoneMesh.visible = false;
                        }
                    });

                    // 4. Update wrist (arm) cylinder (with offset)
                    const lm9_for_wrist_dir = landmarks[9].position3D;

                    if (lm0 && lm9_for_wrist_dir) {
                        const handDirection = new THREE.Vector3().subVectors(lm0, lm9_for_wrist_dir).normalize();
                        let xOffsetFactor = 0;
                        if (handednessLabel === 'Right') {
                            xOffsetFactor = 1;
                        } else if (handednessLabel === 'Left') {
                            xOffsetFactor = -1;
                        }

                        // === 1. ãƒ”ãƒ³ã‚¯ã®ãƒ¡ã‚¤ãƒ³ã‚·ãƒªãƒ³ãƒ€ãƒ¼ (é•·ã„) ===
                        const longWristLength = WORLD_SCALE * WRIST_LONG_LENGTH_FACTOR;
                        const longWristEnd = lm0.clone().add(handDirection.clone().multiplyScalar(longWristLength));
                        const longDistance = longWristEnd.distanceTo(lm0);
                        const longMidPoint = new THREE.Vector3().lerpVectors(lm0, longWristEnd, 0.5);
                        longMidPoint.x += WRIST_OFFSET_X * xOffsetFactor;

                        const armCylinder = hand.armMainCylinder;
                        armCylinder.position.copy(longMidPoint);
                        armCylinder.scale.set(1, longDistance, 1);
                        armCylinder.visible = true;

                        // === 2. é»’ã„ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã‚·ãƒªãƒ³ãƒ€ãƒ¼ (çŸ­ã„ & ã‚ªãƒ•ã‚»ãƒƒãƒˆ) ===
                        const shortWristLength = WORLD_SCALE * WRIST_OUTLINE_SHORT_LENGTH_FACTOR;
                        const startOffset = WORLD_SCALE * OUTLINE_WRIST_START_OFFSET_FACTOR;

                        const actualLength = Math.max(0.01, shortWristLength - startOffset);

                        const outlineStartPoint = lm0.clone().add(handDirection.clone().multiplyScalar(startOffset));
                        const shortWristEnd = outlineStartPoint.clone().add(handDirection.clone().multiplyScalar(actualLength));

                        const shortDistance = shortWristEnd.distanceTo(outlineStartPoint);
                        const shortMidPoint = new THREE.Vector3().lerpVectors(outlineStartPoint, shortWristEnd, 0.5);
                        shortMidPoint.x += WRIST_OFFSET_X * xOffsetFactor;

                        const outlineArmCylinder = hand.outlineArmCylinder;
                        outlineArmCylinder.position.copy(shortMidPoint);
                        outlineArmCylinder.scale.set(1, shortDistance, 1);
                        outlineArmCylinder.visible = true;

                        const orientation = new THREE.Vector3().subVectors(longWristEnd, lm0).normalize();
                        const up = new THREE.Vector3(0, 1, 0);

                        armCylinder.quaternion.setFromUnitVectors(up, orientation);
                        outlineArmCylinder.quaternion.setFromUnitVectors(up, orientation);
                    } else {
                        hand.armMainCylinder.visible = false;
                        hand.outlineArmCylinder.visible = false;
                    }

                    // 5. Update the extra wrist dot (extraWristDot) - No outline for this
                    if (lm0 && lm17) {
                        const wristDotPos = new THREE.Vector3().lerpVectors(lm0, lm17, 0.65);

                        hand.extraWristDot.position.copy(wristDotPos);
                        hand.extraWristDot.scale.setScalar(extraDotThickness);
                        hand.extraWristDot.visible = true;
                    } else {
                        hand.extraWristDot.visible = false;
                    }

                    // 6. Update palm mesh
                    const lm1 = landmarks[1].position3D;
                    const lm2 = landmarks[2].position3D;
                    const lm13 = landmarks[13].position3D;

                    const outlinePalm = hand.outlinePalmMesh;

                    if (lm0 && lm1 && lm2 && lm5 && lm9 && lm13 && lm17) {
                        const vertices_palm = new Float32Array([
                            lm0.x, lm0.y, lm0.z,
                            lm1.x, lm1.y, lm1.z,
                            lm2.x, lm2.y, lm2.z,
                            lm5.x, lm5.y, lm5.z,
                            lm9.x, lm9.y, lm9.z,
                            lm13.x, lm13.y, lm13.z,
                            lm17.x, lm17.y, lm17.z
                        ]);

                        const indices = new Uint16Array([
                            0, 1, 2, 0, 2, 3, 0, 3, 4, 0, 4, 5, 0, 5, 6, 0, 6, 1
                        ]);

                        // --- ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒƒã‚·ãƒ¥ã®æ›´æ–° ---
                        const geometry = hand.palmMesh.geometry;
                        let positionAttribute = geometry.getAttribute('position');

                        if (positionAttribute && positionAttribute.count === 7) {
                            positionAttribute.set(vertices_palm);
                            positionAttribute.needsUpdate = true;
                        } else {
                            positionAttribute = new THREE.BufferAttribute(vertices_palm, 3);
                            geometry.setAttribute('position', positionAttribute);
                        }

                        if (geometry.index === null || geometry.index.count !== indices.length) {
                            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
                        }
                        hand.palmMesh.visible = true;

                        // --- ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ãƒ¡ãƒƒã‚·ãƒ¥ã®æ›´æ–° ---
                        const outlineGeometry = outlinePalm.geometry;

                        let outlinePositionAttribute = outlineGeometry.getAttribute('position');
                        if (outlinePositionAttribute && outlinePositionAttribute.count === 7) {
                            outlinePositionAttribute.set(vertices_palm);
                            outlinePositionAttribute.needsUpdate = true;
                        } else {
                            outlinePositionAttribute = new THREE.BufferAttribute(vertices_palm, 3);
                            outlineGeometry.setAttribute('position', outlinePositionAttribute);
                        }

                        if (outlineGeometry.index === null || outlineGeometry.index.count !== indices.length) {
                            outlineGeometry.setIndex(new THREE.BufferAttribute(indices, 1));
                        }
                        outlinePalm.visible = true;

                    } else {
                        hand.palmMesh.visible = false;
                        outlinePalm.visible = false;
                    }

                    hand.isVisible = true;

                } else {
                    // Hide all elements when not detected
                    if (hand.isVisible) {
                        // ãƒ¡ã‚¤ãƒ³ãƒœãƒ‡ã‚£
                        hand.jointMeshes.forEach(s => s.visible = false);
                        hand.boneMeshes.forEach(c => c.visible = false);
                        hand.armMainCylinder.visible = false;
                        hand.palmMesh.visible = false;
                        hand.extraWristDot.visible = false;

                        // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³
                        hand.outlineJointMeshes.forEach(s => s.visible = false);
                        hand.outlineBoneMeshes.forEach(c => c.visible = false);
                        hand.outlineArmCylinder.visible = false;
                        hand.outlinePalmMesh.visible = false;

                        hand.isVisible = false;
                    }
                }
            }

            threeRenderer.render(threeScene, threeCamera);
        }

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            threeRenderer.render(threeScene, threeCamera);
        }

        // Start camera and tracking on window load
        window.onload = function () {
            onWindowResize();
            startCamera();
            animate();
        }
    </script>
</body>
</html>
